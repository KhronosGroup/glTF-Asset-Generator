# Contributing to the glTF Asset Generator 
The following is a reference on how to add a new set of tests, as well as setting expectations on general practices we want the code in this repro to follow.

## Best Practices
+ Code is as readable as possible. 
  + We anticipate developers that encounter issues with the models generated by this code will want to look into the code to see how that model is put together. Because of this, we emphasize intuitive code flow, usage of comments, and general readability.
  + Don't remove properties when creating a model. To reduce potential confusion, we'd prefer properties to only be added during the creation process.

+ Aim to have fewer than thirteen rows and fewer than seven columns in the model group's readme table (not counting headers).
  + Each model added creates another row. Having too many rows in a table makes it difficult to read due to needing scrolling too much to view the entire model group's readme. Consider splitting the model group into two or more that are closely related.
  + Each property being tested adds another column, and usually adds another model as well. Having too many columns results in results in github's markdown squishing the table to make everything fit.

+ Clearly identify models that are designed to fail to load. (Negative tests) 
  + A client that is conformant with the glTF 2.0 spec is expected to successfully render any model created by the glTF Asset Generator, unless explicitly noted otherwise. 
  + If a model (or entire group of models) are not expected to load on a conformant client, then the model(s) must be marked as such in the readme and manifest.

## Setting Up The glTF Asset Generator In Visual Studio Code (VS Code)
1. Use `git clone https://github.com/KhronosGroup/glTF-Asset-Generator.git` to download the repro.
2. [Install and launch VS Code.](https://code.visualstudio.com/Download)
3. Open the local copy of the repro in VS Code.
  1. Select `Explorer` from the sidebar.
  2. Select `Open Folder`.
  3. Select the location of the `glTF-Asset-Generator` folder.
4. Install the extension `C# for VS Code (powered by OmniSharp)`. There will likely be a popup prompt to take this action.
  + After installation, either relaunch VS Code or reload the extension. 
5. Press F5 or select `Start Debugging` from the debug menu.

### Setting Up Model Screenshots And Other Images
Screenshots are generated in a step separately from running the glTF Asset Generator, which also includes the moving of textures and figures into the output folders.
This is done to speed up debugging. The creation of screenshots is a lengthy process and often the screenshots are not needed until the majority of debugging has been completed.
1. Download the [ScreenshotGenerator](https://github.com/kcoley/screenshotGenerator)
  + Please follow the directions in that repro's readme on how to build the generator.
  + Place the folder containing the Screenshot Generator inside of the glTF-Asset-Generator directory `.\glTF-Asset-Generator\ScreenshotGenerator\`
2. Run the PowerShell script [SampleImageHelper.ps1](SampleImageHelper.ps1)

### Common Errors
+ The error message `Configured debug type 'coreclr' is encountered when debugging in VS Code 
  + This is caused by debugging without `C# for VS Code (powered by OmniSharp)` being correctly installed and loaded.
  + Be sure to reload the extension after installing it, or relaunching VS Code.
+ Error message encountered while debugging `Unhandled Exception: System.UnauthorizedAccessException: Access to the path is denied.`
  + A file could not be overwritten. 
  + Check that the file isn't open in another program and that it isn't set to readonly.
+ Error message encountered while debugging `An unhandled exception of type 'System.IO.IOException' occurred in System.IO.FileSystem.dll: 'The requested operation cannot be performed on a file with a user-mapped section open'`
    + Encountered when running the debugger again too quickly after having just run it.
    + Wait a few seconds longer between debugging sessions to allow the OS to release its locks on the files. 

## Steps to Creating a New Model Group
The sections below detail the specifics of each of the following steps. 
1. [Create a Model Group Readme Template in Markdown.](#create-a-model-group-readme-template-in-markdown)
2. [Create a New Model Group Class.](#create-a-new-model-group-class)
3. Delete undesired models and screenshots from the local [Output](Output) folder. (Files will be overwritten, but not deleted) 
4. Compile and run the build.
5. [Generate Screenshots.](#generate-screenshots)

## Create a Model Group Readme Template in Markdown
Every model group will generate a readme. The code starts with a template specific to that model group, then inserts a generated table based on the models created.

1. Create a .md file named after the model group (same name as the class) to the [ReadmeTemplates](Source/ReadmeTemplates) folder.
2. At the top of the template, describe what area is being tested by this group of models. A statement of purpose to quickly explain why these models are useful.
3. Optionally use `~~HeaderTable~~`. This text will be replaced with a table of properties that are present but not being actively tested. Remove this from the template if no `CommonProperties` are set.
4. Add `~~Table~~` to the template. This text will be replaced with the code generated table of test properties and models in the model group. This is required!

### Readme Tips
+ Models will be listed in the readme in the order they are created in code.
+ Property names and values as listed in the readme are formatted by the [ReadmeStringHelper](Source/ReadmeStringHelper.cs) class, which adds spaces, fixes capitalization, and converts values into strings. 
+ Use `":white_check_mark:"` :white_check_mark: to show that something is enabled or has a positive result. Use `":x:"` :x: to show something is disabled or has a negative result.
+ When including images in a table, use a thumbnail that is the size the image is expected to be viewed at, and link it to a full-size image. This avoids issues with images being stretched.

### Readme Template
```
These models are intended to test...  

The following table shows the properties that are set for every model.  

~~HeaderTable~~
 
The following table shows the properties that are set for a given model.  

~~Table~~ 
```

### Figures
Use images to better explain how a model is setup. This is especially useful for showing model properties that aren't necessarily visible, like UV coordinates or joint skeletons.

1. Create the image
  + Use [draw.io](https://www.draw.io/) to create figures. Export as a PNG, zoom 100%, selection only, Crop.
  + Save the project as an xml for use as a template in the Resources folder.
2. Add the files to the project.
  + Place the PNG in [.\Resources\Figures](Source/Resources/Figures) and set the file properties to "Copy if newer" (Visual Code?)
  + Place the template in [.\Resources\Templates](Source/Resources/Templates)
3. Declare the images as being used in a model group.
  + At the top of the model group class that will be using this image, add `UseFigure(imageList, "IMAGEFILENAME");`
4. Insert the image into the readme template.
  + This can be done with either markdown or HTML formatting.
`![alt-text](Figures/IMAGEFILENAME.png)`  
`<img src="Figures/IMAGEFILENAME.png">`

Be careful of adding images that are too large to a model group's readme, as this can cause weird spacing issues with markdown tables.
+ Clamp the size of the image to keep the image from changing cell widths and heights too much 
`<img src="Figures/BigImage.png" width="144" height="144" align="middle">`

## Create a New Model Group Class
1. Create a copy of the [ModelGroup_Template](Source/Resources/Templates/ModelGroup_Template.cs) and place it under the [ModelGroups](Source/ModelGroups) folder.
2. Name the Class and .cs file as appropriate for what is being tested. For related model groups, use a CATEGORY_NAME format.
3. Add the name of the model group to the `ModelGroupId` enum in [ModelGroup](Source/ModelGroup.cs) (in alphabetical order). Then in the new class set the `Id` as that enum.
4. Call the class from [Program](Source/Program.cs). This is done by creating an instance of the class to add to the `allModelGroups` list (in alphabetical order). 
5. Add code to the new model group. Add new values to the `PropertyName` enum in `Property.cs` as needed. 

### Structure of a Model Group
Declare the following values at the beginning of the constructor
+ Add the figures being used to the `UseFigure` list (See [Figures](#figures) above)
+ Declare the textures being used and add them to the `UseTexture` list. 
`var TextureImage = UseTexture(imageList, "FILENAME")`
+ Declare camera position(s) if a custom one will be used.
+ Declare property values that will be used in more than one model. Add properties used by every model to the `CommonProperties` list.
+ To not generate sample images for the model group, set `NoSampleImages` to true here. This needs to be done if the models are not expected to load successfully.

Assemble the model in the `CreateModel` function.
+ The properties that will be passed to `setProperties` are declared in this function's properties and should be changed to fit the needs of the specific model group.
+ Create the base model (Model with no properties set that are the intended test target). Typically this involves generating the mesh primitive by calling `MeshPrimitive.CreateSinglePlane()` . Avoid creating new base models where possible.
+ Create new objects that make up the parts of the model that will have values set.
+ Call `setProperties`, which will set the desired test values on the component model objects.
+ Assemble and return the model, creating a new `Model` object using the component model objects.

Add helper functions that reduce duplicate code below `CreateModel`. 
+ Generally, this is where the properties list is populated, which is used in creating the model group readme (See [Properties](#properties) below)
+ These functions should be specific to the one model group.

Create the anonymous methods
Inside of the code block `this.Models = new List<Model>` is where the values for each specific model will be set.
If no values are set on a model, leave a comment to show that was intentional.
```C#
CreateModel((properties, meshPrimitive) => {
	// There are no properties set on this model.
}),
```
Otherwise, modify the component model objects that were passed in with the desired test values.
Be careful to only modify the objects and not replace them! If the object is set equal to a new object, then the ref will point at a new object instead of updating the desired object. Instead only modify values of the object, or work with lists of objects.

At the bottom of the model group `GenerateUsedPropertiesList()` is called. This is used in creating the model group readme and won't need to be modified.

### Typical Model Group
+ The first model has no properties set and is intended to be used as a control during testing.
+ The last model has all properties set (as possible) and is intended as a quick test of having combinations of properties set.
+ Other models are either individual properties being set, or combinations of interest (ones that are likely to interact and cause issues).

### Runtime Layer
The [Runtime layer](Source/Runtime) is a group of classes that are used to represent the glTF model as an object. It also has the functions for converting that object into a glTF file.
+ It is often easier to modify the individual classes separately, and then combine them together into a Runtime.GLTF object only after all of the other changes have been made.
+ When manipulating lists, create the desired list outside of the Runtime layer and only set the Runtime layer collection after the list values have been changed. This is to avoid calls like `MeshPrimitives.ElementAt(2)` in favor of `MeshPrimitives[2]`.

## Properties
Properties are attributes that can be set on a model. For example, Doublesided is a property and it can have a value of true or false.

For each tested property that is set on a model, a [Property](Source/Property.cs) object needs to be created. 
```C#
properties.Add(new Property(PropertyName.PROPERTYNAME, PROPERTYVALUE));
```
The enum will be the name of a column on the readme. The value will be displayed in that column.
Readme columns are ordered based on the int value for `PropertyName` enums in the [Property](Source/Property.cs) class.
If having a property name doesn't make sense, use `Description` as the enum and use an explanatory string as the value.

## Post Runtime Changes
There are some specific types of models that the [Runtime layer](Source/Runtime) isn't setup to create. For these cases there is an option to make post Runtime tweaks, specifically for cases when it doesn't make sense to make the changes to the Runtime code to do the same thing.

Steps to add Post Runtime Changes
1. Add `Action<glTFLoader.Schema.Gltf> postRuntimeChanges = null` to `CreateModel()` properties
2. Add this block of code to `CreateModel()` after the model is created.
```C#
if (postRuntimeChanges != null)
{
    model.PostRuntimeChanges = postRuntimeChanges;
}
```
3. Add the change that will be made post runtime and call it as a part of the anonymous method that sets the model's properties.
```C#
CreateModel((properties, material) => {
	// Set normal model properties here
	properties.Add(new Property(PropertyName.Description, "Model with post runtime changes"));
}, (gltf) => {gltf.Scenes.First().Nodes = new []{0,}; }),
```

## Setting Custom Camera Translation Values
The default camera position assumes that the base square plane model is being used. This is insufficient for some other models where the model is either too big or moves outside of the frame. In these cases, set a custom camera position.

The translation of the camera is from the world coordinate 0,0,0 using Z to control the distance from the model and X to control the angle.

Setting a custom camera translation for a model group involves just setting the Camera object when creating a new model, in the `CreateModel` function.
```C#
return new Model
{
    Properties = properties,
    GLTF = CreateGLTF(() => new Runtime.Scene()
    {
        Nodes = nodes
    }),
    Camera = new Manifest.Camera(new Vector3(0.5f, 0.0f, 0.6f))
};
```

Things get more complicated when setting camera translation on a model-by-model basis.
Note that the null set and check are not needed if every model in the model group needs a custom camera translation, but not all the same one.
1. Declare the desired camera translation(s) at the top of the model group's constructor.
```C#
var closeCamera = new Manifest.Camera(new Vector3(0.5f, 0.0f, 0.6f));
```
2. Add `Action<Model> setCamera = null` to `CreateModel()` properties.
3. Add this block of code to `CreateModel()` after the model is created.
```C#
if (setCamera != null)
{
    setCamera(model);
}
```
4. Set the camera translation as a part of the anonymous method that sets the model's properties.
```C#
CreateModel((properties, material) => {
	// Set normal model properties here
	properties.Add(new Property(PropertyName.Description, "Model with a custom camera translation"));
}, (model) => { model.Camera = closeCamera; }),
```

## Creating a new base model
New base models are created in order to reduce duplicate code and to help focus model groups on the properties that are specifically being tested.

Steps to add a new base model:
1. Create an abstract partial class of [ModelGroup](Source/ModelGroup.cs). Preface the name of the file with `ModelGroup_` to show this relation.
2. Create a static partial class of the lowest level component model object. Typically, this is `MeshPrimitive`. This should not create the entire glTF object if possible.
3. Create a function to create the desired base object. Be sure to name the function something descriptive of the resulting model, along the lines of `CreateCube()`
4. Set the desired values for the base model and return the object.

### Tips When Adding a New Base Model
+ Try to center the model's position on 0,0,0 for consistency and to avoid needing a custom camera translation.
+ When adding a base model keep in mind other users will likely need to look through this code in order to understand the model when debugging issues. Doing things like labeling groups of positions can be a big help!

## Generate Screenshots
The [ScreenshotGenerator](https://github.com/kcoley/screenshotGenerator) is used to create sample images of the models. SampleImageHelper.ps1 is then used to move the screenshots and figures into the correct directories.
[SampleImageHelper.ps1](SampleImageHelper.ps1) is not run automatically, to save time when debugging. If a code change adds models or modifies the appearance of existing models, then this script must be run before checking in!  
See [Building the Project](BUILDING_THE_PROJECT.MD) for instructions.
