using glTFLoader.Schema;
using System.Collections.Generic;
using System;
using System.IO;
using System.Reflection;
using System.Diagnostics;
using System.Text;
using System.Linq;

namespace AssetGenerator
{
    class ExtraData: Extras
    {
        public string Attributes { get; set; }
    }
    internal class Program
    {
        private static void Main(string[] args)
        {
            Stopwatch.StartNew();

            var executingAssembly = Assembly.GetExecutingAssembly();
            var executingAssemblyFolder = Path.GetDirectoryName(executingAssembly.Location);
            var imageFolder = Path.Combine(executingAssemblyFolder, "ImageDependencies");

            Tests[] testBatch = new Tests[]
            {
                Tests.Material,
                Tests.Material_Alpha,
                Tests.Material_MetallicRoughness,
                Tests.Texture_Sampler,
                Tests.Primitive_Attribute
            };

            foreach (var test in testBatch)
            {
                TestValues makeTest = new TestValues(test);
                var combos = ComboHelper.AttributeCombos(makeTest);
                var csv = new StringBuilder();
                var md = new StringBuilder();
                List<string> mdLogHeader = new List<string>(); ;
                List<List<string>> mdLogPrereqs = new List<List<string>>();
                List<List<string>> mdLog = new List<List<string>>();
                string lastName = null;

                // Delete any preexisting files in the output directories, then create those directories if needed
                var assetFolder = Path.Combine(executingAssemblyFolder, test.ToString());
                var trashFolder = Path.Combine(executingAssemblyFolder, "Delete");
                bool tryAgain = true;
                while (tryAgain)
                {
                    try
                    {
                        Directory.Move(assetFolder, trashFolder);
                        Directory.Delete(trashFolder, true);
                        tryAgain = false;
                    }
                    catch (DirectoryNotFoundException)
                    {
                        // Do nothing
                        tryAgain = false;
                    }
                    catch (IOException)
                    {
                        Console.WriteLine("Unable to delete the directory.");
                        Console.WriteLine("Verify that there are no open files and that the current user has write permission to that directory.");
                        Console.WriteLine("Press any key to try again.");
                        Console.ReadKey();
                        tryAgain = true;
                    }
                }

                Directory.CreateDirectory(assetFolder);

                // Setup the log file header
                mdLogHeader.Add("The following table shows the properties that are set for every model.  ");
                mdLogHeader.Add("No attributes are explicitly set in every model generated by this test, other than those in the base model.  ");
                mdLogHeader.Add("The following table shows the properties that are set for a given model.  ");
                mdLogHeader.Add("All values of Byte and Short are normalized unsigned.  ");

                if (makeTest.requiredAttributes != null)
                {
                    // List attributes that are set in every generated model (prerequisites)
                    mdLogPrereqs.Add(new List<string>()); // First line of table must be blank
                    mdLogPrereqs.Add(new List<string>
                    {
                    "Attribute", // First cells are a static label
                    "**Values**"
                    });
                    mdLogPrereqs.Add(new List<string>
                    {
                    ":---:", // Hyphens for row after header
                    ":---:",
                    });
                    for (int i = 0; i < makeTest.requiredAttributes.Count; i++)
                    {
                        string attributeName;
                        attributeName = makeTest.requiredAttributes[i].name.ToString();
                        attributeName = LogStringHelper.GenerateNameWithSpaces(attributeName);
                        mdLogPrereqs.Add(new List<string>
                        {
                        attributeName,
                        LogStringHelper.ConvertTestValueToString(makeTest.requiredAttributes[i])
                        });
                    }
                }

                // Now start the table for generated models
                mdLog.Add(new List<string>()); // First line of table must be blank
                mdLog.Add(new List<string>
                {
                    "Index" // First cell is a static header name
                });
                mdLog.Add(new List<string>
                {
                    ":---:" // Hyphens for row after header 
                });
                for (int i = 0; i < makeTest.attributes.Count; i++)
                {
                    string attributeName;
                    if (makeTest.attributes[i].prerequisite != AttributeName.Undefined && makeTest.attributes[i].attributeGroup == 0)
                    {
                        attributeName = makeTest.attributes[i].prerequisite.ToString() + makeTest.attributes[i].name.ToString();
                    }
                    else
                    {
                        attributeName =  makeTest.attributes[i].name.ToString();
                    }
                    attributeName = LogStringHelper.GenerateNameWithSpaces(attributeName);
                    if (attributeName != lastName) // Skip duplicate names caused by non-binary attributes
                    {
                        lastName = attributeName;
                        mdLog[1].Add(attributeName);
                        mdLog[2].Add(":---:");
                    }
                }

                int numCombos = combos.Count;
                for (int comboIndex = 0; comboIndex < numCombos; comboIndex++)
                {
                    string[] name = LogStringHelper.GenerateName(combos[comboIndex]);

                    var gltf = new Gltf
                    {
                        Asset = new Asset
                        {
                            Generator = "glTF Asset Generator",
                            Version = "2.0",
                            Extras = new ExtraData
                            {
                                Attributes = String.Join(" - ", name)
                            }
                        }
                    };

                    var dataList = new List<Data>();

                    var geometryData = new Data(test.ToString() + "_" + comboIndex + ".bin");
                    dataList.Add(geometryData);
                    Runtime.GLTF wrapper = Common.SinglePlaneWrapper(gltf, geometryData);
                    Runtime.Material mat = new Runtime.Material();

                    if (makeTest.testArea == Tests.Material)
                    {
                        mat.MetallicRoughnessMaterial = new Runtime.MetallicRoughnessMaterial();

                        foreach (Attribute req in makeTest.requiredAttributes)
                        {
                            if (req.name == AttributeName.MetallicFactor)
                            {
                                mat.MetallicRoughnessMaterial.MetallicFactor = req.value;
                            }
                        }

                        foreach (Attribute attribute in combos[comboIndex])
                        {
                            if (attribute.name == AttributeName.EmissiveFactor)
                            {
                                mat.EmissiveFactor = attribute.value;
                            }
                            else if (attribute.name == AttributeName.NormalTexture)
                            {
                                mat.NormalTexture = new Runtime.Texture();
                                mat.NormalTexture.Source = attribute.value;
                            }
                            else if (attribute.name == AttributeName.Scale && attribute.prerequisite == AttributeName.NormalTexture)
                            {
                                mat.NormalScale = attribute.value;
                            }
                            else if (attribute.name == AttributeName.OcclusionTexture)
                            {
                                mat.OcclusionTexture = new Runtime.Texture();
                                mat.OcclusionTexture.Source = attribute.value;
                            }
                            else if (attribute.name == AttributeName.Strength && attribute.prerequisite == AttributeName.OcclusionTexture)
                            {
                                mat.OcclusionStrength = attribute.value;
                            }
                            else if (attribute.name == AttributeName.EmissiveTexture)
                            {
                                mat.EmissiveTexture = new Runtime.Texture();
                                mat.EmissiveTexture.Source = attribute.value;
                            }
                        }
                    }

                    if (makeTest.testArea == Tests.Material_Alpha)
                    {
                        mat.MetallicRoughnessMaterial = new Runtime.MetallicRoughnessMaterial();
                        mat.NormalTexture = new Runtime.Texture();

                        foreach (Attribute req in makeTest.requiredAttributes)
                        {
                            if (req.name == AttributeName.BaseColorFactor)
                            {
                                mat.MetallicRoughnessMaterial.BaseColorFactor = req.value;
                            }
                            else if (req.name == AttributeName.NormalTexture)
                            {
                                mat.NormalTexture.Source = req.value;
                            }
                        }

                        foreach (Attribute attribute in combos[comboIndex])
                        {
                            if (attribute.name == AttributeName.AlphaMode_Opaque ||
                                attribute.name == AttributeName.AlphaMode_Mask ||
                                attribute.name == AttributeName.AlphaMode_Blend)
                            {
                                mat.AlphaMode = attribute.value;
                            }
                            else if (attribute.name == AttributeName.AlphaCutoff)
                            {
                                mat.AlphaCutoff = attribute.value;
                            }
                            else if (attribute.name == AttributeName.DoubleSided)
                            {
                                mat.DoubleSided = attribute.value;
                            }
                        }
                    }

                    else if (makeTest.testArea == Tests.Material_MetallicRoughness)
                    {
                        foreach (Attribute attribute in combos[comboIndex])
                        {
                            if (mat.MetallicRoughnessMaterial == null)
                            {
                                mat.MetallicRoughnessMaterial = new Runtime.MetallicRoughnessMaterial();
                            }

                            if (attribute.name == AttributeName.BaseColorFactor)
                            {
                                mat.MetallicRoughnessMaterial.BaseColorFactor = attribute.value;
                            }
                            else if (attribute.name == AttributeName.MetallicFactor)
                            {
                                mat.MetallicRoughnessMaterial.MetallicFactor = attribute.value;
                            }
                            else if (attribute.name == AttributeName.RoughnessFactor)
                            {
                                mat.MetallicRoughnessMaterial.RoughnessFactor = attribute.value;
                            }
                            else if (attribute.name == AttributeName.BaseColorTexture)
                            {
                                mat.MetallicRoughnessMaterial.BaseColorTexture = new Runtime.Texture();
                                mat.MetallicRoughnessMaterial.BaseColorTexture.Source = attribute.value;
                            }
                            else if (attribute.name == AttributeName.MetallicRoughnessTexture)
                            {
                                mat.MetallicRoughnessMaterial.MetallicRoughnessTexture = new Runtime.Texture();
                                mat.MetallicRoughnessMaterial.MetallicRoughnessTexture.Source = attribute.value;
                            }
                        }
                    }

                    else if (makeTest.testArea == Tests.Texture_Sampler)
                    {
                        mat.MetallicRoughnessMaterial = new Runtime.MetallicRoughnessMaterial();
                        mat.MetallicRoughnessMaterial.BaseColorTexture = new Runtime.Texture();
                        mat.MetallicRoughnessMaterial.BaseColorTexture.Sampler = new Runtime.Sampler();

                        foreach (Attribute req in makeTest.requiredAttributes)
                        {
                            if (req.name == AttributeName.BaseColorTexture)
                            {
                                mat.MetallicRoughnessMaterial.BaseColorTexture.Source = req.value;
                            }
                        }

                        foreach (Attribute attribute in combos[comboIndex])
                        {
                            if (attribute.name == AttributeName.MagFilter_Nearest ||
                                attribute.name == AttributeName.MagFilter_Linear)
                            {
                                mat.MetallicRoughnessMaterial.BaseColorTexture.Sampler.MagFilter = attribute.value;
                            }
                            else if (attribute.name == AttributeName.MinFilter_Nearest ||
                                     attribute.name == AttributeName.MinFilter_Linear ||
                                     attribute.name == AttributeName.MinFilter_NearestMipmapNearest ||
                                     attribute.name == AttributeName.MinFilter_LinearMipmapNearest ||
                                     attribute.name == AttributeName.MinFilter_NearestMipmapLinear ||
                                     attribute.name == AttributeName.MinFilter_LinearMipmapLinear)
                            {
                                mat.MetallicRoughnessMaterial.BaseColorTexture.Sampler.MinFilter = attribute.value;
                            }
                            else if (attribute.name == AttributeName.WrapS_ClampToEdge ||
                                     attribute.name == AttributeName.WrapS_MirroredRepeat ||
                                     attribute.name == AttributeName.WrapS_Repeat)
                            {
                                mat.MetallicRoughnessMaterial.BaseColorTexture.Sampler.WrapS = attribute.value;
                            }
                            else if (attribute.name == AttributeName.WrapT_ClampToEdge ||
                                     attribute.name == AttributeName.WrapT_MirroredRepeat ||
                                     attribute.name == AttributeName.WrapT_Repeat)
                            {
                                mat.MetallicRoughnessMaterial.BaseColorTexture.Sampler.WrapT = attribute.value;
                            }
                        }
                    }

                    else if (makeTest.testArea == Tests.Primitive_Attribute)
                    {
                        // Clear values from the default model, so we can test those values not being set
                        wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Normals = null;

                        mat.MetallicRoughnessMaterial = new Runtime.MetallicRoughnessMaterial();
                        mat.MetallicRoughnessMaterial.BaseColorTexture = new Runtime.Texture();
                        mat.NormalTexture = new Runtime.Texture();

                        foreach (Attribute req in makeTest.requiredAttributes)
                        {
                            if (req.name == AttributeName.BaseColorTexture)
                            {
                                mat.MetallicRoughnessMaterial.BaseColorTexture.Source = req.value;
                                mat.MetallicRoughnessMaterial.BaseColorTexture.TexCoordIndex = 0;
                            }
                        }

                        foreach (Attribute attribute in combos[comboIndex])
                        {
                            if (attribute.name == AttributeName.Normal)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Normals = attribute.value;
                            }
                            else if (attribute.name == AttributeName.Tangent)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Tangents = attribute.value;
                            }
                            else if (attribute.name == AttributeName.TexCoord0_Float)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordsComponentType =
                                    Runtime.MeshPrimitive.TextureCoordsComponentTypeEnum.FLOAT;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordSets[0] = attribute.value;
                            }
                            else if (attribute.name == AttributeName.TexCoord0_Byte)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordsComponentType =
                                    Runtime.MeshPrimitive.TextureCoordsComponentTypeEnum.NORMALIZED_UBYTE;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordSets[0] = attribute.value;
                            }
                            else if (attribute.name == AttributeName.TexCoord0_Short)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordsComponentType =
                                    Runtime.MeshPrimitive.TextureCoordsComponentTypeEnum.NORMALIZED_USHORT;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordSets[0] = attribute.value;
                            }
                            else if (attribute.name == AttributeName.TexCoord1_Float)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordsComponentType =
                                    Runtime.MeshPrimitive.TextureCoordsComponentTypeEnum.FLOAT;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordSets.Add(attribute.value);

                                var NormText = makeTest.requiredAttributes.Find(e => e.name == AttributeName.NormalTexture);
                                mat.NormalTexture.Source = NormText.value;
                                mat.NormalTexture.TexCoordIndex = 1;
                            }
                            else if (attribute.name == AttributeName.TexCoord1_Byte)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordsComponentType =
                                    Runtime.MeshPrimitive.TextureCoordsComponentTypeEnum.NORMALIZED_UBYTE;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordSets.Add(attribute.value);

                                var NormText = makeTest.requiredAttributes.Find(e => e.name == AttributeName.NormalTexture);
                                mat.NormalTexture.Source = NormText.value;
                                mat.NormalTexture.TexCoordIndex = 1;
                            }
                            else if (attribute.name == AttributeName.TexCoord1_Short)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordsComponentType =
                                    Runtime.MeshPrimitive.TextureCoordsComponentTypeEnum.NORMALIZED_USHORT;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].TextureCoordSets.Add(attribute.value);

                                var NormText = makeTest.requiredAttributes.Find(e => e.name == AttributeName.NormalTexture);
                                mat.NormalTexture.Source = NormText.value;
                                mat.NormalTexture.TexCoordIndex = 1;
                            }
                            else if (attribute.name == AttributeName.Color_Vector3_Float)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorComponentType = Runtime.MeshPrimitive.ColorComponentTypeEnum.FLOAT;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorType = Runtime.MeshPrimitive.ColorTypeEnum.VEC3;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Colors = attribute.value;
                            }
                            else if (attribute.name == AttributeName.Color_Vector4_Float)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorComponentType = Runtime.MeshPrimitive.ColorComponentTypeEnum.FLOAT;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorType = Runtime.MeshPrimitive.ColorTypeEnum.VEC4;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Colors = attribute.value;
                            }
                            else if (attribute.name == AttributeName.Color_Vector3_Byte)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorComponentType = Runtime.MeshPrimitive.ColorComponentTypeEnum.NORMALIZED_UBYTE;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorType = Runtime.MeshPrimitive.ColorTypeEnum.VEC3;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Colors = attribute.value;
                            }
                            else if (attribute.name == AttributeName.Color_Vector4_Byte)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorComponentType = Runtime.MeshPrimitive.ColorComponentTypeEnum.NORMALIZED_UBYTE;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorType = Runtime.MeshPrimitive.ColorTypeEnum.VEC4;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Colors = attribute.value;
                            }
                            else if (attribute.name == AttributeName.Color_Vector3_Short)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorComponentType = Runtime.MeshPrimitive.ColorComponentTypeEnum.NORMALIZED_USHORT;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorType = Runtime.MeshPrimitive.ColorTypeEnum.VEC3;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Colors = attribute.value;
                            }
                            else if (attribute.name == AttributeName.Color_Vector4_Short)
                            {
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorComponentType = Runtime.MeshPrimitive.ColorComponentTypeEnum.NORMALIZED_USHORT;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].ColorType = Runtime.MeshPrimitive.ColorTypeEnum.VEC4;
                                wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Colors = attribute.value;
                            }
                        }
                    }

                    wrapper.Scenes[0].Meshes[0].MeshPrimitives[0].Material = mat;
                    wrapper.BuildGLTF(ref gltf, geometryData);

                    if (makeTest.imageAttributes != null)
                    {
                        foreach (var image in makeTest.imageAttributes)
                        {
                            if (File.Exists(Path.Combine(imageFolder, image.Name)))
                            {
                                File.Copy(Path.Combine(imageFolder, image.Name), Path.Combine(assetFolder, image.Name), true);
                            }
                            else
                            {
                                Debug.WriteLine(imageFolder + " does not exist");
                            }
                        }
                    }

                    var assetFile = Path.Combine(assetFolder, test.ToString() + "_" + comboIndex + ".gltf");
                    glTFLoader.Interface.SaveModel(gltf, assetFile);

                    foreach (var data in dataList)
                    {
                        data.Writer.Flush();

                        var dataFile = Path.Combine(assetFolder, data.Name);
                        File.WriteAllBytes(dataFile, ((MemoryStream)data.Writer.BaseStream).ToArray());
                    }

                    mdLog.Add(new List<string> // New row for a new model
                    {
                        // Displays the number of the model and is a link to the model
                        '[' + comboIndex.ToString() + "](./" + test.ToString() + '_' + comboIndex + ".gltf)"
                    }); 
                    int logIndex = mdLog.Count - 1;
                    List<int> nonBinaryUsed = new List<int>();
                    foreach (var possibleAttribute in makeTest.attributes)
                    {
                        var attributeIndex = combos[comboIndex].FindIndex(e =>
                            e.name == possibleAttribute.name &&
                            e.prerequisite == possibleAttribute.prerequisite);
                        if (attributeIndex != -1)
                        {
                            if (possibleAttribute.attributeGroup > 0)
                            {
                                var alreadyUsed = nonBinaryUsed.Exists(x => x == possibleAttribute.attributeGroup);
                                if (alreadyUsed)
                                {
                                    // Overwrites the empty cell if a nonbinary of the same time had already been encountered and not used
                                    mdLog[logIndex][mdLog[logIndex].Count - 1] = LogStringHelper.ConvertTestValueToString(possibleAttribute);
                                }
                                else
                                {
                                    // Creates a new cell, since this nonbinary type had not been encountered before
                                    mdLog[logIndex].Add(LogStringHelper.ConvertTestValueToString(possibleAttribute));
                                    nonBinaryUsed.Add(possibleAttribute.attributeGroup);
                                }
                            }
                            else
                            {
                                mdLog[logIndex].Add(LogStringHelper.ConvertTestValueToString(possibleAttribute));
                            }
                        }
                        else
                        {
                            if (possibleAttribute.attributeGroup > 0)
                            {
                                var alreadyUsed = nonBinaryUsed.Exists(x => x == possibleAttribute.attributeGroup);
                                if (!alreadyUsed)
                                {
                                    mdLog[logIndex].Add(" ");
                                    nonBinaryUsed.Add(possibleAttribute.attributeGroup);
                                }
                            }
                            else
                            {
                                mdLog[logIndex].Add(" ");
                            }
                        }
                    }

                    var writeToLog = string.Format("{0},{1}", comboIndex, String.Join(" - ", name));
                    csv.AppendLine(writeToLog);
                }

                if (makeTest.requiredAttributes != null)
                {
                    md.AppendLine(mdLogHeader[0]); // Header for the prerequisite table. Only show if the table has values.
                    foreach (var line in mdLogPrereqs)
                    {
                        md.AppendLine(String.Join(" | ", line));
                    }
                }
                else
                {
                    md.AppendLine(mdLogHeader[1]); // If there are no prerequisites, this is the header.
                }

                md.AppendLine(" "); // Linebreak
                md.AppendLine(mdLogHeader[2]); // Header for test grid table
                foreach (var x in mdLog)
                {
                    var resultByte = x.FirstOrDefault(s => s.Contains("Byte"));
                    if (resultByte != null)
                    {
                        md.AppendLine(mdLogHeader[3]);
                        break;
                    }
                    var resultShort = mdLog.FirstOrDefault(s => s.Contains("Short"));
                    if (resultShort != null)
                    {
                        md.AppendLine(mdLogHeader[3]);
                        break;
                    }
                }

                foreach (var line in mdLog)
                {
                    md.AppendLine(String.Join(" | ", line));
                }
                
                var logFile = Path.Combine(assetFolder, test.ToString() + "_log.csv");
                File.WriteAllText(logFile, csv.ToString());
                var mdLogFile = Path.Combine(assetFolder, "README.md");
                File.WriteAllText(mdLogFile, md.ToString());
            }
            Console.WriteLine("Model Creation Complete!");
            Console.WriteLine("Completed in : " + TimeSpan.FromTicks(Stopwatch.GetTimestamp()).ToString());
        }
    }
}
